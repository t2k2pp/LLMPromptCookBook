# レシピ1-3: 制約条件の明示的な指定

## 課題（Problem）
LLMは与えられた制約条件を暗黙的に理解または推測することができず、以下のような問題が発生します：

- パフォーマンス要件を満たさないコードの生成
- セキュリティ上の懸念がある実装の提案
- プロジェクト固有の規約に違反するコード
- スケーラビリティを考慮していない設計

## 解決方法（Solution）
制約条件を以下のカテゴリに分類し、明示的に指定します：

1. 機能的制約
2. 非機能要件
3. 技術的制約
4. コーディング規約
5. セキュリティ要件

## プロンプト例

### 制約条件を明示的に指定したプロンプト

```
あなたは、大規模なマイクロサービスアーキテクチャのバックエンドシステムを設計・実装するシニアソフトウェアアーキテクトです。

タスク：
Eコマースシステムの注文処理サービスのコア部分を実装してください。

制約条件：

【機能的制約】
1. べき等性の保証
   - 同一注文IDでの重複処理を防止
   - 冪等キーの有効期限は24時間

2. トランザクション管理
   - 分散トランザクションのサポート
   - 補償トランザクションの実装

3. データ整合性
   - 在庫データとの整合性確保
   - 注文状態の一貫性維持

【非機能要件】
1. パフォーマンス
   - レイテンシ: 99パーセンタイルで200ms以下
   - スループット: 1000 TPS以上
   - 同時接続数: 最大10,000セッション

2. 可用性
   - SLA: 99.99%
   - フェイルオーバー時間: 10秒以内
   - リージョン間レプリケーション

3. スケーラビリティ
   - 水平スケーリング対応
   - ステートレス設計
   - キャッシュ戦略の実装

【技術的制約】
1. 使用技術
   - 言語: TypeScript 5.0
   - フレームワーク: NestJS 10.x
   - データベース: MongoDB 6.0
   - メッセージブローカー: Apache Kafka 3.5

2. アーキテクチャ
   - イベント駆動アーキテクチャ
   - CQRS パターンの採用
   - DDD原則の遵守

3. 監視・運用
   - OpenTelemetryによる分散トレーシング
   - Prometheusメトリクス対応
   - 構造化ログ出力

【コーディング規約】
1. コード品質
   - Sonar Qualityゲート: AランクまたはSランク
   - テストカバレッジ: 85%以上
   - 循環的複雑度: 10未満

2. 命名規則
   - インターフェース: 'I'プレフィックス
   - 実装クラス: 具象的な名詞
   - メソッド: 動詞 + 名詞

3. エラー処理
   - カスタム例外クラスの使用
   - エラーコードの標準化
   - 詳細なエラーログ

【セキュリティ要件】
1. 認証・認可
   - JWTベースの認証
   - ロールベースのアクセス制御
   - トークンの有効期限管理

2. データ保護
   - 機密情報の暗号化
   - PII データの匿名化
   - 監査ログの保存

3. セキュリティ対策
   - 入力バリデーション
   - SQLインジェクション対策
   - レートリミッティング

期待する出力：
1. 主要なインターフェースとクラスの実装
2. エラーハンドリングの実装
3. テストケースのサンプル
```

## 制約条件の指定パターン

### 1. 定量的な制約

パフォーマンスやスケーラビリティに関する制約は、具体的な数値で指定します：

- [制約条件の分類と関係性](https://github.com/t2k2pp/LLMPromptCookBook/blob/main/chapter%201/chapter%201-3/recipe1-3-patterns.mermaid)
- [制約を考慮した実装例](https://github.com/t2k2pp/LLMPromptCookBook/blob/main/chapter%201/chapter%201-3/recipe1-3-code.ts)

## 実装の分析

上記の実装例では、明示的に指定された制約条件が以下のように反映されています：

1. **機能的制約の実現**
   - べき等性の保証（キャッシュによる重複チェック）
   - トランザクション管理（@Transactional デコレータ）
   - 補償トランザクションの実装（在庫予約の解放）

2. **非機能要件の実現**
   - パフォーマンス測定（処理時間の記録）
   - レートリミッティング（@RateLimit デコレータ）
   - トレーシング（OpenTelemetry統合）

3. **セキュリティ要件の実現**
   - 入力バリデーション
   - PIIデータの匿名化
   - 詳細なログ記録

## 改善ポイント

1. **制約条件の優先順位付け**
   - クリティカルな制約の明確化
   - トレードオフの検討
   - 段階的な実装計画

2. **制約条件の検証可能性**
   - 自動テストによる検証
   - 監視メトリクスの設定
   - 定期的な制約チェック

3. **制約条件の文書化**
   - APIドキュメントへの反映
   - 運用マニュアルの整備
   - トラブルシューティングガイド

## ベストプラクティス

1. **制約の分類と整理**
   - カテゴリごとの整理
   - 相互依存関係の明確化
   - 実現可能性の評価

2. **制約条件の具体化**
   - 定量的な指標の設定
   - 測定方法の定義
   - 閾値の設定

3. **制約条件の管理**
   - バージョン管理
   - 変更履歴の記録
   - レビュープロセスの確立

## 一般的な失敗パターン

1. **曖昧な制約条件**
   ```
   // 悪い例
   "高速な処理が必要です"
   "セキュアな実装にしてください"
   ```

   ```
   // 良い例
   "レスポンスタイム: 99パーセンタイルで200ms以下"
   "OWASP Top 10の脆弱性対策を実装すること"
   ```

2. **矛盾する制約**
   ```
   // 問題のある例
   - 厳密なACID特性の保証
   - 1ms以下のレイテンシ
   - 地理分散環境での展開
   ```

   ```
   // 現実的な例
   - 結果整合性の許容
   - 読み取り操作の優先
   - キャッシュ戦略の活用
   ```

3. **検証困難な制約**
   ```
   // 検証困難な例
   "ユーザーフレンドリーな実装"
   "将来の拡張に対応"
   ```

   ```
   // 検証可能な例
   "エラーメッセージは具体的な対処方法を含むこと"
   "新機能追加時のコード変更が30%以下"
   ```

## Tips

1. **制約条件の優先順位**
   - 必須要件と任意要件の区別
   - ビジネスインパクトの評価
   - 技術的な実現可能性の考慮

2. **制約条件の文書化**
   - 標準テンプレートの使用
   - 具体例の提供
   - レビューチェックリストの活用

3. **制約条件の評価**
   - 定期的なレビュー
   - メトリクスによる監視
   - フィードバックの収集

## Warning

- 過度に厳密な制約は避ける
- 技術的な実現可能性を常に考慮する
- コストとベネフィットのバランスを取る

## 関連レシピ

- レシピ1-2: コンテキストの効果的な提供方法
- レシピ2-1: ボイラープレートコードの生成
- レシピ3-1: コード品質の評価

## まとめ

制約条件を明示的に指定することで、以下のメリットが得られます：

1. LLMからより適切な応答を得られる
2. 実装の品質が向上する
3. レビューが容易になる
4. 保守性が向上する

制約条件は、プロジェクトの進行に伴って進化させていく必要があります。定期的なレビューと更新を行い、常に最適な状態を維持することが重要です。
